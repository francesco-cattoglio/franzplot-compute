use std::path::Path;

use crate::compute_graph::ComputeGraph;
use crate::device_manager::Manager;
use crate::rendering::camera;
use crate::rendering::SceneRenderer;
use crate::rendering::texture::{Texture, Masks};
use crate::rendering::model::Model;
use crate::node_graph;
use serde::{Serialize, Deserialize};

pub mod action;
pub use action::Action;

// The State struct encapsulates the whole application state,
// the GUI takes a mutable reference to the state and modifies it
// according to user input. The state contains both the data
// that the user is constantly editing (UserState) and the "rendered result"
// of that data (AppState). This distinction is very important w.r.t
// saving to file: we don't want to serialize compute shaders,
// we only want to save the graph, the variables and the scene settings.

#[derive(Clone, Deserialize, Serialize)]
pub struct UserState {
    #[serde(rename = "graph")]
    pub node_graph: node_graph::NodeGraph,
    pub globals_names: Vec<String>,
    pub globals_init_values: Vec<f32>,
    #[serde(default = "TSs::new_unknown")]
    pub tss: TSs,
}

impl Default for UserState {
    fn default() -> Self {
        UserState {
            tss: TSs::new_now(),
            ..Default::default()
        }
    }
}
impl UserState {
    pub fn write_to_frzp(&mut self, path: &Path) {
        let mut file = std::fs::File::create(path).unwrap();
        let ser_config = ron::ser::PrettyConfig::new()
            .with_depth_limit(5)
            .with_indentor("  ".to_owned())
            .with_separate_tuple_members(true)
            .with_enumerate_arrays(true);
        // update the time_stamp to remember the last time the file was saved
        self.tss.fs = chrono::offset::Utc::now().timestamp();
        let to_serialize = FileVersion::V2(self.clone());
        let serialized_data = ron::ser::to_string_pretty(&to_serialize, ser_config).unwrap();
        let mut contents = r##"//// FRANZPLOT DATA FILE V1.2 \\\\

//   This file should not be edited by hand,
//   as doing so might easily corrupt the data.
//   To edit this file, open it in Franzplot, version 22.10 or higher

"##.to_string();

        contents.push_str(&serialized_data);
        use std::io::Write;
        file.write_all(contents.as_bytes()).unwrap(); // TODO: handle writing failures
    }

    pub fn read_from_frzp(path: &Path) -> Result<Self, String> {
        let mut file = std::fs::File::open(path).unwrap();
        let mut contents = String::new();
        use std::io::Read;
        file.read_to_string(&mut contents)
            .map_err(|error| format!("Error opening file: {}", &error))?;
        let saved_data: FileVersion = ron::from_str(&contents)
            .map_err(|_| "Error reading file contents. Is this a franzplot file?".to_string())?;
        match saved_data {
            FileVersion::V0(user_state) => {
                // loading an older file that does NOT have timestamp infos
                // serde should be able to fill them automagically
                Ok(user_state)
            }
            FileVersion::V1(mut user_state, time_stamps) => {
                // if we load a V1, user_state will not contain the timestamps,
                // then what we can do is overwrite the autogenerated ones
                // with the one we read from the file
                user_state.tss = time_stamps;
                Ok(user_state)
            }
            FileVersion::V2(user_state) => {
                // this time, everything should be there already, including the timestamps
                Ok(user_state)
            }
        }
    }
}

// This structure holds the timestamps that we add to the saved files
#[derive(Clone, Default, Deserialize, Serialize)]
pub struct TSs {
    pub fc: i64,
    pub fs: i64,
    pub vn: u32,
    pub hs: u64, // currently unused
}

impl TSs {
    pub fn new_now() -> Self {
        use rand::Rng;
        let random_number = rand::thread_rng().gen::<u32>();
        Self {
            hs: 0,
            vn: random_number,
            fc: chrono::offset::Utc::now().timestamp(),
            fs: chrono::offset::Utc::now().timestamp(),
        }
    }

    pub fn new_unknown() -> Self {
        use rand::Rng;
        let random_number = rand::thread_rng().gen::<u32>();
        Self {
            hs: 0,
            vn: random_number,
            fc: 0,
            fs: 0,
        }
    }
}

#[derive(Deserialize, Serialize)]
enum FileVersion {
    V0(UserState),
    V1(UserState, TSs),
    V2(UserState),
}

pub struct Assets {
    pub materials: Vec<Texture>,
    pub masks: Masks,
    pub models: Vec<Model>,
}

pub struct Sensitivity {
    pub graph_zoom: f32,
    pub scene_zoom: f32,
    pub camera_horizontal: f32,
    pub camera_vertical: f32,
}

impl Default for Sensitivity {
    fn default() -> Self {
        Sensitivity {
            graph_zoom: 1.0,
            scene_zoom: 1.0,
            camera_horizontal: 1.0,
            camera_vertical: 1.0,
        }
    }
}

pub struct AppState {
    pub camera_controller: Box<dyn camera::Controller>,
    pub camera_enabled: bool,
    pub camera_lock_up: bool,
    pub camera_ortho: bool, // TODO: all these camera settings should NOT be here, move them somewhere else!
    pub auto_scene_on_processing: bool,
    pub camera: camera::Camera,
    pub assets: Assets,
    pub manager: Manager,
    pub comp_graph: Option<ComputeGraph>,
    pub renderer: SceneRenderer,
    pub sensitivity: Sensitivity,
    pub egui_ctx: egui::Context,
}

impl AppState {
    pub fn new(manager: Manager, assets: Assets) -> Self {
        let camera = camera::Camera::default();
        let camera_controller = Box::new(camera::VTKController::new());
        AppState {
            //computable_scene,
            assets,
            camera,
            auto_scene_on_processing: true,
            camera_enabled: false,
            camera_lock_up: true,
            camera_ortho: false,
            camera_controller,
            egui_ctx: egui::Context::default(),
            renderer: SceneRenderer::new_with_axes(&manager),
            manager,
            comp_graph: None,
            sensitivity: Sensitivity::default(),
        }
    }
    pub fn set_wireframe_axes(&mut self, length: i32, cross_size: f32) {
        self.renderer.set_wireframe_axes(&self.manager, length, cross_size);
    }

    pub fn clear_wireframe_axes(&mut self) {
        self.renderer.clear_wireframe_axes();
    }

    pub fn set_axes_labels(&mut self, axis_length: i32, label_size: f32) {
        self.renderer.set_axes_labels(&self.manager, axis_length as f32, label_size);
    }

    pub fn clear_axes_labels(&mut self) {
        self.renderer.clear_axes_labels();
    }

    pub fn update_camera(&mut self, camera_inputs: &camera::InputState) {
        if self.camera_enabled {
            self.camera_controller.update_camera(&mut self.camera, camera_inputs, &self.sensitivity, self.camera_lock_up);
        }
    }

    pub fn render_scene(&mut self, extent: wgpu::Extent3d, view: &wgpu::TextureView) -> Result<(), String> {
        // create aliases
        let renderer = &mut self.renderer;
        let camera = &mut self.camera;
        renderer.resize_if_needed(&self.manager, extent);
        let aspect_ratio = extent.width as f32/extent.height as f32;
        let projection_matrix = if self.camera_ortho {
            camera.build_ortho_matrix(aspect_ratio)
        } else {
            camera.build_projection_matrix(aspect_ratio)
        };
        renderer.update_proj(projection_matrix);
        renderer.update_view(camera.build_view_matrix());
        // after updating everything, redraw the scene to the texture
        renderer.render(&self.manager, view);
        Ok(())
    }
}


// TODO: RENAME THIS, maybe even move it somewhere else
pub fn user_to_app_state(app: &mut AppState, user: &mut UserState) -> Result<(), String> {
    // - clear previous node graph errors
    // - try to create a new compute graph
    // - if successful, update the scene rendering and report recoverable errors
    // - if unsuccessful, report the unrecoverable error to the user
    let process_result = crate::compute_graph::create_compute_graph(&app.manager.device, &app.assets, &user);
    match process_result {
        Ok((compute_graph, recoverable_errors)) => {
            // run the first compute, and create the matcaps in the SceneRenderer
            compute_graph.run_compute(&app.manager.device, &app.manager.queue);
            app.renderer.recreate_matcaps(&app.manager, &app.assets, compute_graph.matcaps());
            app.comp_graph = Some(compute_graph);
            if recoverable_errors.is_empty() {
                Ok(())
            } else {
                for error in recoverable_errors.into_iter() {
                    user.node_graph.mark_error(error.into());
                }
                Err("Recoverable errors detected".into())
            }
        },
        Err(unrecoverable_error) => {
            let formatted_error = format!("Unrecoverable error: {:?}", &unrecoverable_error);
            user.node_graph.mark_error(unrecoverable_error.into());
            Err(formatted_error) // TODO: better handling
        }
    }
}

pub struct State {
    pub app: AppState,
    pub user: UserState,
    pub egui_state: egui_winit::State,
    pub screen_surface: wgpu::Surface,
}

impl State {
    // this function will likely be called only once, at program start
    // at program start, we can just set the user and app data to its default value
    pub fn new<T>(manager: Manager, assets: Assets, window: &winit::window::Window, event_loop: &winit::event_loop::EventLoop<T>) -> Self {
        let mut egui_state = egui_winit::State::new(event_loop);
        egui_state.set_pixels_per_point(window.scale_factor() as f32);

        let (size, screen_surface) = unsafe {
            let size = window.inner_size();
            let surface = manager.instance.create_surface(window);
            (size, surface)
        };

        Self {
            app: AppState::new(manager, assets),
            user: UserState::default(),
            egui_state,
            screen_surface,
        }
    }

    pub fn get_frame(&mut self) -> Option<wgpu::SurfaceTexture> {
        // get the framebuffer frame. We might need to re-create the swapchain if for some
        // reason our current one is outdated
        let maybe_frame = self.screen_surface.get_current_texture();
        match maybe_frame {
                Ok(surface_frame) => {
                    Some(surface_frame)
                }
                Err(wgpu::SurfaceError::Outdated) => {
                    // This interesting thing happens when we just resized the window but due to a
                    // race condition the winit ResizeEvent has not fired just yet. We might resize
                    // the swapchain here, but doing so would leave the app in a borked state:
                    // imgui needs to be notified about the resize as well, otherwise it will run
                    // a scissor test on a framebuffer of a different physical size and the
                    // validation layer will panic. The best course of action is doing nothing at
                    // all, the problem will fix itself on the next frame, when the Resized event
                    // fires.
                    None
                }
                Err(wgpu::SurfaceError::OutOfMemory) => {
                    panic!("Out Of Memory error in frame rendering");
                }
                Err(wgpu::SurfaceError::Timeout) => {
                    println!("Warning: timeout error in frame rendering!");
                    None
                }
                Err(wgpu::SurfaceError::Lost) => {
                    println!("Warning: frame Lost error in frame rendering");
                    None
                }
        }
    }

    pub fn process(&mut self, action: Action) -> Result<(), String>{
        match action {
            Action::WriteToFile(path) => {
                self.user.write_to_frzp(&path);
                Ok(())
            } ,
            Action::OpenFile(path) => {
                self.user = UserState::read_from_frzp(&path)?;
                Ok(())
            },
            Action::NewFile() => {
                // reset the user state: this will zero out the node graph and its global vars
                self.user = UserState::default();
                // clear all the created renderables and the entire compute graph
                self.app.renderer.clear_matcaps();
                self.app.comp_graph = None;
                // new timestamp for the new file
                Ok(())
            },
            Action::RenderScene(extent, view) => {
                // create aliases
                self.app.render_scene(extent, view)
            },
            Action::ProcessUserState() => {
                user_to_app_state(&mut self.app, &mut self.user)
            }
            Action::UpdateGlobals(pairs) => {
                // if the compute graph exists, tell it to update the globals
                if let Some(graph) = &mut self.app.comp_graph {
                    graph.update_globals(&self.app.manager.device, &self.app.manager.queue, pairs);
                    Ok(())
                } else {
                    dbg!("tried to update globals, but there is no graph!"); // TODO: better handling
                    Ok(())
                }
            }
        }
    }
}
