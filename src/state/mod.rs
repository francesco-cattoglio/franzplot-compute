use std::path::Path;

use crate::CustomEvent;
use crate::compute_graph::ComputeGraph;
use crate::device_manager::Manager;
use crate::gui::Gui;
use crate::node_graph::NodeGraph;
use crate::rendering::SWAPCHAIN_FORMAT;
use crate::rendering::camera;
use crate::rendering::SceneRenderer;
use crate::rendering::texture::{Texture, Masks};
use crate::rendering::model::Model;
use crate::node_graph;
use egui_wgpu::Renderer;
use serde::{Serialize, Deserialize};

pub mod action;
pub use action::Action;
use winit::dpi::PhysicalSize;

// The State struct encapsulates the whole application state,
// the GUI takes a mutable reference to the state and modifies it
// according to user input. The state contains both the data
// that the user is constantly editing (UserState) and the "rendered result"
// of that data (AppState). This distinction is very important w.r.t
// saving to file: we don't want to serialize compute shaders,
// we only want to save the graph, the variables and the scene settings.

#[derive(Clone, Deserialize, Serialize)]
pub struct UserState {
    #[serde(rename = "graph")]
    pub node_graph: node_graph::NodeGraph,
    pub globals_names: Vec<String>,
    pub globals_init_values: Vec<f32>,
    #[serde(default = "TSs::new_unknown")]
    pub tss: TSs,
}

impl Default for UserState {
    fn default() -> Self {
        UserState {
            node_graph: NodeGraph::default(),
            globals_names: Vec::new(),
            globals_init_values: Vec::new(),
            tss: TSs::new_now(),
        }
    }
}
impl UserState {
    // TODO: proper error handling
    pub fn write_to_frzp(&mut self, path: &Path) {
        let mut file = std::fs::File::create(path).unwrap();
        let ser_config = ron::ser::PrettyConfig::new()
            .with_depth_limit(5)
            .with_indentor("  ".to_owned())
            .with_separate_tuple_members(true)
            .with_enumerate_arrays(true);
        // update the time_stamp to remember the last time the file was saved
        self.tss.fs = chrono::offset::Utc::now().timestamp();
        let to_serialize = FileVersion::V2(self.clone());
        let serialized_data = ron::ser::to_string_pretty(&to_serialize, ser_config).unwrap();
        let mut contents = r##"//// FRANZPLOT DATA FILE V1.2 \\\\

//   This file should not be edited by hand,
//   as doing so might easily corrupt the data.
//   To edit this file, open it in Franzplot, version 22.10 or higher

"##.to_string();

        contents.push_str(&serialized_data);
        use std::io::Write;
        file.write_all(contents.as_bytes()).unwrap(); // TODO: handle writing failures
    }

    pub fn read_from_frzp(path: &Path) -> Result<Self, String> {
        let mut file = std::fs::File::open(path).unwrap();
        let mut contents = String::new();
        use std::io::Read;
        file.read_to_string(&mut contents)
            .map_err(|error| format!("Error opening file: {}", &error))?;
        let saved_data: FileVersion = ron::from_str(&contents)
            .map_err(|_| "Error reading file contents. Is this a franzplot file?".to_string())?;
        match saved_data {
            FileVersion::V0(user_state) => {
                // loading an older file that does NOT have timestamp infos
                // serde should be able to fill them automagically
                Ok(user_state)
            }
            FileVersion::V1(mut user_state, time_stamps) => {
                // if we load a V1, user_state will not contain the timestamps,
                // then what we can do is overwrite the autogenerated ones
                // with the one we read from the file
                user_state.tss = time_stamps;
                Ok(user_state)
            }
            FileVersion::V2(user_state) => {
                // this time, everything should be there already, including the timestamps
                Ok(user_state)
            }
        }
    }
}

// This structure holds the timestamps that we add to the saved files
#[derive(Clone, Default, Deserialize, Serialize)]
pub struct TSs {
    pub fc: i64,
    pub fs: i64,
    pub vn: u32,
    pub hs: u64, // currently unused
}

impl TSs {
    pub fn new_now() -> Self {
        use rand::Rng;
        let random_number = rand::thread_rng().gen::<u32>();
        Self {
            hs: 0,
            vn: random_number,
            fc: chrono::offset::Utc::now().timestamp(),
            fs: chrono::offset::Utc::now().timestamp(),
        }
    }

    pub fn new_unknown() -> Self {
        use rand::Rng;
        let random_number = rand::thread_rng().gen::<u32>();
        Self {
            hs: 0,
            vn: random_number,
            fc: 0,
            fs: 0,
        }
    }
}

#[derive(Deserialize, Serialize)]
enum FileVersion {
    V0(UserState),
    V1(UserState, TSs),
    V2(UserState),
}

pub struct Assets {
    pub materials: Vec<Texture>,
    pub masks: Masks,
    pub models: Vec<Model>,
}

pub struct Sensitivity {
    pub graph_zoom: f32,
    pub scene_zoom: f32,
    pub camera_horizontal: f32,
    pub camera_vertical: f32,
}

impl Default for Sensitivity {
    fn default() -> Self {
        Sensitivity {
            graph_zoom: 1.0,
            scene_zoom: 1.0,
            camera_horizontal: 1.0,
            camera_vertical: 1.0,
        }
    }
}

pub struct AppState {
    pub camera_controller: Box<dyn camera::Controller>,
    pub camera_enabled: bool,
    pub camera_lock_up: bool,
    pub camera_ortho: bool, // TODO: all these camera settings should NOT be here, move them somewhere else!
    pub auto_scene_on_processing: bool,
    pub camera: camera::Camera,
    pub assets: Assets,
    pub manager: Manager,
    pub comp_graph: Option<ComputeGraph>,
    pub renderer: SceneRenderer,
    pub sensitivity: Sensitivity,
    pub egui_ctx: egui::Context,
}

impl AppState {
    pub fn new(manager: Manager, assets: Assets) -> Self {
        let camera = camera::Camera::default();
        let camera_controller = Box::new(camera::VTKController::new());
        AppState {
            //computable_scene,
            assets,
            camera,
            auto_scene_on_processing: true,
            camera_enabled: false,
            camera_lock_up: true,
            camera_ortho: false,
            camera_controller,
            egui_ctx: egui::Context::default(),
            renderer: SceneRenderer::new_with_axes(&manager),
            manager,
            comp_graph: None,
            sensitivity: Sensitivity::default(),
        }
    }
    pub fn set_wireframe_axes(&mut self, length: i32, cross_size: f32) {
        self.renderer.set_wireframe_axes(&self.manager, length, cross_size);
    }

    pub fn clear_wireframe_axes(&mut self) {
        self.renderer.clear_wireframe_axes();
    }

    pub fn set_axes_labels(&mut self, axis_length: i32, label_size: f32) {
        self.renderer.set_axes_labels(&self.manager, axis_length as f32, label_size);
    }

    pub fn clear_axes_labels(&mut self) {
        self.renderer.clear_axes_labels();
    }

    pub fn update_camera(&mut self, camera_inputs: &camera::InputState) {
        if self.camera_enabled {
            self.camera_controller.update_camera(&mut self.camera, camera_inputs, &self.sensitivity, self.camera_lock_up);
        }
    }

    pub fn render_scene(&mut self, extent: wgpu::Extent3d, view: &wgpu::TextureView) -> Result<(), String> {
        // create aliases
        let renderer = &mut self.renderer;
        let camera = &mut self.camera;
        renderer.resize_if_needed(&self.manager, extent);
        let aspect_ratio = extent.width as f32/extent.height as f32;
        let projection_matrix = if self.camera_ortho {
            camera.build_ortho_matrix(aspect_ratio)
        } else {
            camera.build_projection_matrix(aspect_ratio)
        };
        renderer.update_proj(projection_matrix);
        renderer.update_view(camera.build_view_matrix());
        // after updating everything, redraw the scene to the texture
        renderer.render(&self.manager, view);
        Ok(())
    }
}


// TODO: RENAME THIS, maybe even move it somewhere else
pub fn user_to_app_state(app: &mut AppState, user: &mut UserState) -> Result<(), String> {
    // - clear previous node graph errors
    // - try to create a new compute graph
    // - if successful, update the scene rendering and report recoverable errors
    // - if unsuccessful, report the unrecoverable error to the user
    let process_result = crate::compute_graph::create_compute_graph(&app.manager.device, &app.assets, &user);
    match process_result {
        Ok((compute_graph, recoverable_errors)) => {
            // run the first compute, and create the matcaps in the SceneRenderer
            compute_graph.run_compute(&app.manager.device, &app.manager.queue);
            app.renderer.recreate_matcaps(&app.manager, &app.assets, compute_graph.matcaps());
            app.comp_graph = Some(compute_graph);
            if recoverable_errors.is_empty() {
                Ok(())
            } else {
                for error in recoverable_errors.into_iter() {
                    user.node_graph.mark_error(error.into());
                }
                Err("Recoverable errors detected".into())
            }
        },
        Err(unrecoverable_error) => {
            let formatted_error = format!("Unrecoverable error: {:?}", &unrecoverable_error);
            user.node_graph.mark_error(unrecoverable_error.into());
            Err(formatted_error) // TODO: better handling
        }
    }
}

pub struct State {
    pub app: AppState,
    pub user: UserState,
    pub gui: Box<dyn Gui>,
    pub event_loop: winit::event_loop::EventLoopProxy<CustomEvent>,
    pub egui_state: egui_winit::State,
    pub egui_rpass: egui_wgpu::Renderer,
    pub screen_surface: wgpu::Surface,
    // BEWARE: we NEED to store the surface_config, because after a resize the window.inner_size()
    // does not reflect the correct value to be used by WGPU scissor rect, so we need to use
    // the width and height stored in the surface_config and use those at redering time
    pub surface_config: wgpu::SurfaceConfiguration,
    pub scene_texture_id: egui::TextureId,
}

impl State {
    // this function will likely be called only once, at program start
    // at program start, we can just set the user and app data to its default value
    pub fn new(manager: Manager, assets: Assets, gui: Box<dyn Gui>, window: &winit::window::Window, event_loop: &winit::event_loop::EventLoop<CustomEvent>) -> Self {
        let mut egui_state = egui_winit::State::new(event_loop);
        egui_state.set_pixels_per_point(window.scale_factor() as f32);

        let (size, screen_surface) = unsafe {
            let size = window.inner_size();
            let surface = manager.instance.create_surface(window);
            (size, surface)
        };
        let surface_config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format: SWAPCHAIN_FORMAT,
            width: size.width,
            height: size.height,
            present_mode: wgpu::PresentMode::AutoNoVsync,
            alpha_mode: wgpu::CompositeAlphaMode::Auto,
        };
        screen_surface.configure(&manager.device, &surface_config);

        // We use the egui_wgpu_backend crate as the render backend.
        let mut egui_rpass = egui_wgpu::Renderer::new(&manager.device, crate::rendering::SWAPCHAIN_FORMAT, 1, 0); // TODO: investigate more how to properly set this

        // first, create a texture that will be used to render the scene and display it inside of imgui
        let scene_texture = Texture::create_output_texture(&manager.device, wgpu::Extent3d{width: 320, height:320, ..Default::default()}, 1);
        let scene_view = scene_texture.texture.create_view(&wgpu::TextureViewDescriptor::default());
        let scene_texture_id = egui_rpass.register_native_texture(&manager.device, &scene_view, egui_wgpu::wgpu::FilterMode::Linear);

        Self {
            app: AppState::new(manager, assets),
            user: UserState::default(),
            gui,
            egui_rpass,
            egui_state,
            event_loop: event_loop.create_proxy(),
            scene_texture_id,
            screen_surface,
            surface_config,
        }
    }

    pub fn resize_frame(&mut self, size: PhysicalSize<u32>) {
        let width = size.width as u32;
        let height = size.height as u32;
        if width >= 8 && height >= 8 {
            self.surface_config.width = width;
            self.surface_config.height = height;
            self.screen_surface.configure(&self.app.manager.device, &self.surface_config);
        }
    }

    pub fn get_frame(&mut self) -> Option<wgpu::SurfaceTexture> {
        // get the framebuffer frame. We might need to re-create the swapchain if for some
        // reason our current one is outdated
        let maybe_frame = self.screen_surface.get_current_texture();
        match maybe_frame {
                Ok(surface_frame) => {
                    Some(surface_frame)
                }
                Err(wgpu::SurfaceError::Outdated) => {
                    // This interesting thing happens when we just resized the window but due to a
                    // race condition the winit ResizeEvent has not fired just yet. We might resize
                    // the swapchain here, but doing so would leave the app in a borked state:
                    // imgui needs to be notified about the resize as well, otherwise it will run
                    // a scissor test on a framebuffer of a different physical size and the
                    // validation layer will panic. The best course of action is doing nothing at
                    // all, the problem will fix itself on the next frame, when the Resized event
                    // fires.
                    dbg!("outdated");
                    None
                }
                Err(wgpu::SurfaceError::OutOfMemory) => {
                    panic!("Out Of Memory error in frame rendering");
                }
                Err(wgpu::SurfaceError::Timeout) => {
                    println!("Warning: timeout error in frame rendering!");
                    None
                }
                Err(wgpu::SurfaceError::Lost) => {
                    println!("Warning: frame Lost error in frame rendering");
                    None
                }
        }
    }

    pub fn render_frame(&mut self, window: &winit::window::Window) -> Result<(), String> {
        let raw_input = self.egui_state.take_egui_input(window);
        let full_output = self.gui.show(&self.app.egui_ctx, raw_input, &mut self.user);
        self.egui_state.handle_platform_output(window, &self.app.egui_ctx, full_output.platform_output);

        let paint_jobs = self.app.egui_ctx.tessellate(full_output.shapes);
        // acquire next frame, or update the swapchain if a resize occurred
        let frame = if let Some(frame) = self.get_frame() {
            frame
        } else {
            // if we are unable to get a frame, skip rendering altogether
            return Ok(());
        };

        // declare an alias to make the rest of the code readable
        let manager = &self.app.manager;
        // use the acquired frame for a rendering pass, which will clear the screen and render the gui
        let mut encoder: wgpu::CommandEncoder =
            self.app.manager.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

        // Upload all resources for the GPU.
        let screen_descriptor = egui_wgpu::renderer::ScreenDescriptor {
            size_in_pixels: [self.surface_config.width, self.surface_config.height],
            pixels_per_point: window.scale_factor() as f32,
        };
        for (id, image_delta) in full_output.textures_delta.set {
            self.egui_rpass.update_texture(&manager.device, &manager.queue, id, &image_delta);
        }
        self.egui_rpass.update_buffers(&manager.device, &manager.queue, &paint_jobs, &screen_descriptor);

        // Record all render passes.
        let frame_view = frame.texture.create_view(&wgpu::TextureViewDescriptor::default());
        self.egui_rpass
            .render(
                &mut encoder,
                &frame_view,
                &paint_jobs,
                &screen_descriptor,
                Some(wgpu::Color::BLACK),
            );
        // Submit the commands.
        manager.queue.submit(std::iter::once(encoder.finish()));

        // Redraw egui
        frame.present();

        Ok(())
    }

    pub fn process(&mut self, action: Action) -> Result<(), String> {
        match action {
            Action::WriteToFile(path) => {
                self.user.write_to_frzp(path);
                Ok(())
            } ,
            Action::OpenFile(path) => {
                self.user = UserState::read_from_frzp(path)?;
                Ok(())
            },
            Action::NewFile() => {
                // reset the user state: this will zero out the node graph and its global vars
                self.user = UserState::default();
                // clear all the created renderables and the entire compute graph
                self.app.renderer.clear_matcaps();
                self.app.comp_graph = None;
                // new timestamp for the new file
                Ok(())
            },
            Action::RenderScene(extent, view) => {
                // create aliases
                self.app.render_scene(extent, view)
            },
            Action::ProcessUserState() => {
                user_to_app_state(&mut self.app, &mut self.user)
            }
            Action::UpdateGlobals(pairs) => {
                // if the compute graph exists, tell it to update the globals
                if let Some(graph) = &mut self.app.comp_graph {
                    graph.update_globals(&self.app.manager.device, &self.app.manager.queue, pairs);
                    Ok(())
                } else {
                    dbg!("tried to update globals, but there is no graph!"); // TODO: better handling
                    Ok(())
                }
            }
            Action::RenderUI(window) => {
                self.render_frame(window)
            }
        }
    }
}
